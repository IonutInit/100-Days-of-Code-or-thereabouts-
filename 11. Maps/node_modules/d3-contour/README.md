# d3-contour

This library computes contour polygons by applying [marching squares](https://en.wikipedia.org/wiki/Marching\_squares) to a rectangular array of numeric values. For example, here is Maungawhau’s topology (the classic `volcano` dataset and `terrain.colors` from R):

[![Volcano Contours](https://raw.githubusercontent.com/d3/d3-contour/main/img/volcano.gif)](https://observablehq.com/@d3/volcano-contours)

For each [threshold value](./#contours\_thresholds), the [contour generator](./#\_contours) constructs a GeoJSON MultiPolygon geometry object representing the area where the input values are greater than or equal to the threshold value. The geometry is in planar coordinates, where ⟨_i_ + 0.5, _j_ + 0.5⟩ corresponds to element _i_ + _jn_ in the input values array. Here is an example that loads a GeoTIFF of surface temperatures, and another that blurs a noisy monochrome PNG to produce smooth contours of cloud fraction:

[![GeoTiff Contours](https://raw.githubusercontent.com/d3/d3-contour/main/img/temperature.png)](https://observablehq.com/@d3/geotiff-contours) [![Cloud Contours](https://raw.githubusercontent.com/d3/d3-contour/main/img/clouds.png)](https://observablehq.com/@d3/cloud-contours)

Since the contour polygons are GeoJSON, you can transform and display them using standard tools; see [d3.geoPath](https://github.com/d3/d3-geo/blob/main/README.md#geoPath), [d3.geoProject](https://github.com/d3/d3-geo-projection/blob/main/README.md#geoProject) and [d3.geoStitch](https://github.com/d3/d3-geo-projection/blob/main/README.md#geoStitch), for example. Here the above contours of surface temperature are displayed in the Natural Earth projection:

[![GeoTiff Contours II](https://raw.githubusercontent.com/d3/d3-contour/main/img/reprojection.png)](https://observablehq.com/@d3/geotiff-contours-ii)

Contour plots can also visualize continuous functions by sampling. Here is the Goldstein–Price function (a test function for global optimization) and a trippy animation of _sin_(_x_ + _y_)_sin_(_x_ - _y_):

[![Contours](https://raw.githubusercontent.com/d3/d3-contour/main/img/goldstein-price.png)](https://observablehq.com/@d3/contours) [![Animated Contours](https://raw.githubusercontent.com/d3/d3-contour/main/img/sin-cos.png)](https://observablehq.com/@d3/animated-contours)

Contours can also show the [estimated density](./#density-estimation) of point clouds, which is especially useful to avoid overplotting in large datasets. This library implements fast two-dimensional kernel density estimation; see [d3.contourDensity](./#contourDensity). Here is a scatterplot showing the relationship between the idle duration and eruption duration for Old Faithful:

[![Density Contours](https://raw.githubusercontent.com/d3/d3-contour/main/img/faithful.png)](https://observablehq.com/@d3/density-contours)

And here is a density contour plot showing the relationship between the weight and price of 53,940 diamonds:

[![Density Contours](https://raw.githubusercontent.com/d3/d3-contour/main/img/diamonds.png)](https://observablehq.com/@d3/density-contours)

## Installing

If you use npm, `npm install d3-contour`. You can also download the [latest release on GitHub](https://github.com/d3/d3-contour/releases/latest). For vanilla HTML in modern browsers, import d3-contour from Skypack:

```html
<script type="module">

import {contours} from "https://cdn.skypack.dev/d3-contour@3";

const c = contours(values);

</script>
```

For legacy environments, you can load d3-contour’s UMD bundle from an npm-based CDN such as jsDelivr; a `d3` global is exported:

```html
<script src="https://cdn.jsdelivr.net/npm/d3-array@3"></script>
<script src="https://cdn.jsdelivr.net/npm/d3-contour@3"></script>
<script>

// Populate a grid of n×m values where -2 ≤ x ≤ 2 and -2 ≤ y ≤ 1.
const n = 256, m = 256, values = new Array(n * m);
for (let j = 0.5, k = 0; j < m; ++j) {
  for (let i = 0.5; i < n; ++i, ++k) {
    values[k] = goldsteinPrice(i / n * 4 - 2, 1 - j / m * 3);
  }
}

// Compute the contour polygons at log-spaced intervals; returns an array of MultiPolygon.
const contours = d3.contours()
    .size([n, m])
    .thresholds(Array.from({ length: 19 }, (_, i) => Math.pow(2, i + 2)))
    (values);

// See https://en.wikipedia.org/wiki/Test_functions_for_optimization
function goldsteinPrice(x, y) {
  return (1 + Math.pow(x + y + 1, 2) * (19 - 14 * x + 3 * x * x - 14 * y + 6 * x * x + 3 * y * y))
      * (30 + Math.pow(2 * x - 3 * y, 2) * (18 - 32 * x + 12 * x * x + 48 * y - 36 * x * y + 27 * y * y));
}

</script>
```

## API Reference

[#](./#contours) d3.contours() · [Source](https://github.com/d3/d3-contour/blob/main/src/contours.js), [Examples](https://observablehq.com/collection/@d3/d3-contour)

Constructs a new contour generator with the default settings.

[#](./#\_contours) _contours_(_values_) · [Source](https://github.com/d3/d3-contour/blob/main/src/contours.js)

Computes the contours for the given array of _values_, returning an array of [GeoJSON](http://geojson.org/geojson-spec.html) [MultiPolygon](http://geojson.org/geojson-spec.html#multipolygon) [geometry objects](http://geojson.org/geojson-spec.html#geometry-objects). Each geometry object represents the area where the input _values_ are greater than or equal to the corresponding [threshold value](./#contours\_thresholds); the threshold value for each geometry object is exposed as _geometry_.value.

The input _values_ must be an array of length _n_×_m_ where \[_n_, _m_] is the contour generator’s [size](./#contours\_size); furthermore, each _values_\[_i_ + _jn_] must represent the value at the position ⟨_i_, _j_⟩. For example, to construct a 256×256 grid for the [Goldstein–Price function](https://en.wikipedia.org/wiki/Test\_functions\_for\_optimization) where -2 ≤ _x_ ≤ 2 and -2 ≤ _y_ ≤ 1:

```js
var n = 256, m = 256, values = new Array(n * m);
for (var j = 0.5, k = 0; j < m; ++j) {
  for (var i = 0.5; i < n; ++i, ++k) {
    values[k] = goldsteinPrice(i / n * 4 - 2, 1 - j / m * 3);
  }
}

function goldsteinPrice(x, y) {
  return (1 + Math.pow(x + y + 1, 2) * (19 - 14 * x + 3 * x * x - 14 * y + 6 * x * x + 3 * y * y))
      * (30 + Math.pow(2 * x - 3 * y, 2) * (18 - 32 * x + 12 * x * x + 48 * y - 36 * x * y + 27 * y * y));
}
```

The returned geometry objects are typically passed to [d3.geoPath](https://github.com/d3/d3-geo/blob/main/README.md#geoPath) to display, using null or [d3.geoIdentity](https://github.com/d3/d3-geo/blob/main/README.md#geoIdentity) as the associated projection.

[#](./#contours\_contour) _contours_.contour(_values_, _threshold_) · [Source](https://github.com/d3/d3-contour/blob/main/src/contours.js), [Examples](https://observablehq.com/@d3/animated-contours)

Computes a single contour, returning a [GeoJSON](http://geojson.org/geojson-spec.html) [MultiPolygon](http://geojson.org/geojson-spec.html#multipolygon) [geometry object](http://geojson.org/geojson-spec.html#geometry-objects) representing the area where the input _values_ are greater than or equal to the given [_threshold_ value](./#contours\_thresholds); the threshold value for each geometry object is exposed as _geometry_.value.

The input _values_ must be an array of length _n_×_m_ where \[_n_, _m_] is the contour generator’s [size](./#contours\_size); furthermore, each _values_\[_i_ + _jn_] must represent the value at the position ⟨_i_, _j_⟩. See [_contours_](./#\_contours) for an example.

[#](./#contours\_size) _contours_.size(\[_size_]) · [Source](https://github.com/d3/d3-contour/blob/main/src/contours.js), [Examples](https://observablehq.com/@d3/animated-contours)

If _size_ is specified, sets the expected size of the input _values_ grid to the [contour generator](./#\_contour) and returns the contour generator. The _size_ is specified as an array \[_n_, _m_] where _n_ is the number of columns in the grid and _m_ is the number of rows; _n_ and _m_ must be positive integers. If _size_ is not specified, returns the current size which defaults to \[1, 1].

[#](./#contours\_smooth) _contours_.smooth(\[_smooth_]) · [Source](https://github.com/d3/d3-contour/blob/main/src/contours.js), [Examples](https://observablehq.com/@d3/contours-smooth)

If _smooth_ is specified, sets whether or not the generated contour polygons are smoothed using linear interpolation. If _smooth_ is not specified, returns the current smoothing flag, which defaults to true.

[#](./#contours\_thresholds) _contours_.thresholds(\[_thresholds_]) · [Source](https://github.com/d3/d3-contour/blob/main/src/contours.js), [Examples](https://observablehq.com/@d3/volcano-contours)

If _thresholds_ is specified, sets the threshold generator to the specified function or array and returns this contour generator. If _thresholds_ is not specified, returns the current threshold generator, which by default implements [Sturges’ formula](https://github.com/d3/d3-array/blob/main/README.md#thresholdSturges).

Thresholds are defined as an array of values \[_x0_, _x1_, …]. The first [generated contour](./#\_contour) corresponds to the area where the input values are greater than or equal to _x0_; the second contour corresponds to the area where the input values are greater than or equal to _x1_, and so on. Thus, there is exactly one generated MultiPolygon geometry object for each specified threshold value; the threshold value is exposed as _geometry_.value.

If a _count_ is specified instead of an array of _thresholds_, then the input values’ [extent](https://github.com/d3/d3-array/blob/main/README.md#extent) will be uniformly divided into approximately _count_ bins; see [d3.ticks](https://github.com/d3/d3-array/blob/main/README.md#ticks).

## Density Estimation

[#](./#contourDensity) d3.contourDensity() · [Source](https://github.com/d3/d3-contour/blob/main/src/density.js), [Examples](https://observablehq.com/@d3/density-contours)

Constructs a new density estimator with the default settings.

[#](./#\_density) _density_(_data_) · [Source](https://github.com/d3/d3-contour/blob/main/src/density.js)

Estimates the density contours for the given array of _data_, returning an array of [GeoJSON](http://geojson.org/geojson-spec.html) [MultiPolygon](http://geojson.org/geojson-spec.html#multipolygon) [geometry objects](http://geojson.org/geojson-spec.html#geometry-objects). Each geometry object represents the area where the estimated number of points per square pixel is greater than or equal to the corresponding [threshold value](./#density\_thresholds); the threshold value for each geometry object is exposed as _geometry_.value. The returned geometry objects are typically passed to [d3.geoPath](https://github.com/d3/d3-geo/blob/main/README.md#geoPath) to display, using null or [d3.geoIdentity](https://github.com/d3/d3-geo/blob/main/README.md#geoIdentity) as the associated projection. See also [d3.contours](./#contours).

The _x_- and _y_-coordinate for each data point are computed using [_density_.x](./#density\_x) and [_density_.y](./#density\_y). In addition, [_density_.weight](./#density\_weight) indicates the relative contribution of each data point (default 1). The generated contours are only accurate within the estimator’s [defined size](./#density\_size).

[#](./#density\_x) _density_.x(\[_x_]) · [Source](https://github.com/d3/d3-contour/blob/main/src/density.js), [Examples](https://observablehq.com/@d3/density-contours)

If _x_ is specified, sets the _x_-coordinate accessor. If _x_ is not specified, returns the current _x_-coordinate accessor, which defaults to:

```js
function x(d) {
  return d[0];
}
```

[#](./#density\_y) _density_.y(\[_y_]) · [Source](https://github.com/d3/d3-contour/blob/main/src/density.js), [Examples](https://observablehq.com/@d3/density-contours)

If _y_ is specified, sets the _y_-coordinate accessor. If _y_ is not specified, returns the current _y_-coordinate accessor, which defaults to:

```js
function y(d) {
  return d[1];
}
```

[#](./#density\_weight) _density_.weight(\[_weight_]) · [Source](https://github.com/d3/d3-contour/blob/main/src/density.js)

If _weight_ is specified, sets the accessor for point weights. If _weight_ is not specified, returns the current point weight accessor, which defaults to:

```js
function weight() {
  return 1;
}
```

[#](./#density\_size) _density_.size(\[_size_]) · [Source](https://github.com/d3/d3-contour/blob/main/src/density.js), [Examples](https://observablehq.com/@d3/density-contours)

If _size_ is specified, sets the size of the density estimator to the specified bounds and returns the estimator. The _size_ is specified as an array \[_width_, _height_], where _width_ is the maximum _x_-value and _height_ is the maximum _y_-value. If _size_ is not specified, returns the current size which defaults to \[960, 500]. The [estimated density contours](./#\_density) are only accurate within the defined size.

[#](./#density\_cellSize) _density_.cellSize(\[_cellSize_]) · [Source](https://github.com/d3/d3-contour/blob/main/src/density.js)

If _cellSize_ is specified, sets the size of individual cells in the underlying bin grid to the specified positive integer and returns the estimator. If _cellSize_ is not specified, returns the current cell size, which defaults to 4. The cell size is rounded down to the nearest power of two. Smaller cells produce more detailed contour polygons, but are more expensive to compute.

[#](./#density\_thresholds) _density_.thresholds(\[_thresholds_]) · [Source](https://github.com/d3/d3-contour/blob/main/src/density.js), [Examples](https://observablehq.com/@d3/density-contours)

If _thresholds_ is specified, sets the threshold generator to the specified function or array and returns this contour generator. If _thresholds_ is not specified, returns the current threshold generator, which by default generates about twenty nicely-rounded density thresholds.

Thresholds are defined as an array of values \[_x0_, _x1_, …]. The first [generated density contour](./#\_density) corresponds to the area where the estimated density is greater than or equal to _x0_; the second contour corresponds to the area where the estimated density is greater than or equal to _x1_, and so on. Thus, there is exactly one generated MultiPolygon geometry object for each specified threshold value; the threshold value is exposed as _geometry_.value. The first value _x0_ should typically be greater than zero.

If a _count_ is specified instead of an array of _thresholds_, then approximately _count_ uniformly-spaced nicely-rounded thresholds will be generated; see [d3.ticks](https://github.com/d3/d3-array/blob/main/README.md#ticks).

[#](./#density\_bandwidth) _density_.bandwidth(\[_bandwidth_]) · [Source](https://github.com/d3/d3-contour/blob/main/src/density.js), [Examples](https://observablehq.com/@d3/density-contours)

If _bandwidth_ is specified, sets the bandwidth (the standard deviation) of the Gaussian kernel and returns the estimate. If _bandwidth_ is not specified, returns the current bandwidth, which defaults to 20.4939…. The specified _bandwidth_ is currently rounded to the nearest supported value by this implementation, and must be nonnegative.

[#](./#density\_contours) _density_.contours(_data_) · [Source](https://github.com/d3/d3-contour/blob/main/src/density.js), [Examples](https://observablehq.com/@d3/density-contours-data)

Return a _contour_(_value_) function that can be used to compute an arbitrary contour on the given data without needing to recompute the underlying grid. The returned _contour_ function also exposes a _contour_.max value which represents the maximum density of the grid.

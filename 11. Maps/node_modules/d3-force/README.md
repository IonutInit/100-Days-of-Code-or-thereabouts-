# d3-force

This module implements a [velocity Verlet](https://en.wikipedia.org/wiki/Verlet\_integration) numerical integrator for simulating physical forces on particles. The simulation is simplified: it assumes a constant unit time step Δ_t_ = 1 for each step, and a constant unit mass _m_ = 1 for all particles. As a result, a force _F_ acting on a particle is equivalent to a constant acceleration _a_ over the time interval Δ_t_, and can be simulated simply by adding to the particle’s velocity, which is then added to the particle’s position.

In the domain of information visualization, physical simulations are useful for studying [networks](https://observablehq.com/@d3/force-directed-graph) and [hierarchies](https://observablehq.com/@d3/force-directed-tree)!

[![Force-Directed Graph](https://raw.githubusercontent.com/d3/d3-force/master/img/graph.png)](https://observablehq.com/@d3/force-directed-graph)[![Force-Directed Tree](https://raw.githubusercontent.com/d3/d3-force/master/img/tree.png)](https://observablehq.com/@d3/force-directed-tree)

You can also simulate circles (disks) with collision, such as for [bubble charts](http://www.nytimes.com/interactive/2012/09/06/us/politics/convention-word-counts.html) or [beeswarm plots](https://observablehq.com/@d3/beeswarm):

[![Collision Detection](https://raw.githubusercontent.com/d3/d3-force/master/img/collide.png)](https://observablehq.com/@d3/collision-detection)[![Beeswarm](https://raw.githubusercontent.com/d3/d3-force/master/img/beeswarm.png)](https://observablehq.com/@d3/beeswarm)

You can even use it as a rudimentary physics engine, say to simulate cloth:

[![Force-Directed Lattice](https://raw.githubusercontent.com/d3/d3-force/master/img/lattice.png)](https://observablehq.com/@d3/force-directed-lattice)

To use this module, create a [simulation](./#simulation) for an array of [nodes](./#simulation\_nodes), and compose the desired [forces](./#simulation\_force). Then [listen](./#simulation\_on) for tick events to render the nodes as they update in your preferred graphics system, such as Canvas or SVG.

## Installing

If you use npm, `npm install d3-force`. You can also download the [latest release on GitHub](https://github.com/d3/d3-force/releases/latest). For vanilla HTML in modern browsers, import d3-force from Skypack:

```html
<script type="module">

import {forceSimulation} from "https://cdn.skypack.dev/d3-force@3";

const simulation = forceSimulation(nodes);

</script>
```

For legacy environments, you can load d3-force’s UMD bundle from an npm-based CDN such as jsDelivr; a `d3` global is exported:

```html
<script src="https://cdn.jsdelivr.net/npm/d3-dispatch@3"></script>
<script src="https://cdn.jsdelivr.net/npm/d3-quadtree@3"></script>
<script src="https://cdn.jsdelivr.net/npm/d3-timer@3"></script>
<script src="https://cdn.jsdelivr.net/npm/d3-force@3"></script>
<script>

const simulation = d3.forceSimulation(nodes);

</script>
```

[Try d3-force in your browser.](https://observablehq.com/collection/@d3/d3-force)

## API Reference

### Simulation

[#](./#forceSimulation) d3.forceSimulation(\[_nodes_]) · [Source](https://github.com/d3/d3-force/blob/master/src/simulation.js)

Creates a new simulation with the specified array of [_nodes_](./#simulation\_nodes) and no [forces](./#simulation\_force). If _nodes_ is not specified, it defaults to the empty array. The simulator [starts](./#simulation\_restart) automatically; use [_simulation_.on](./#simulation\_on) to listen for tick events as the simulation runs. If you wish to run the simulation manually instead, call [_simulation_.stop](./#simulation\_stop), and then call [_simulation_.tick](./#simulation\_tick) as desired.

[#](./#simulation\_restart) _simulation_.restart() · [Source](https://github.com/d3/d3-force/blob/master/src/simulation.js)

Restarts the simulation’s internal timer and returns the simulation. In conjunction with [_simulation_.alphaTarget](./#simulation\_alphaTarget) or [_simulation_.alpha](./#simulation\_alpha), this method can be used to “reheat” the simulation during interaction, such as when dragging a node, or to resume the simulation after temporarily pausing it with [_simulation_.stop](./#simulation\_stop).

[#](./#simulation\_stop) _simulation_.stop() · [Source](https://github.com/d3/d3-force/blob/master/src/simulation.js)

Stops the simulation’s internal timer, if it is running, and returns the simulation. If the timer is already stopped, this method does nothing. This method is useful for running the simulation manually; see [_simulation_.tick](./#simulation\_tick).

[#](./#simulation\_tick) _simulation_.tick(\[_iterations_]) · [Source](https://github.com/d3/d3-force/blob/master/src/simulation.js)

Manually steps the simulation by the specified number of _iterations_, and returns the simulation. If _iterations_ is not specified, it defaults to 1 (single step).

For each iteration, it increments the current [_alpha_](./#simulation\_alpha) by ([_alphaTarget_](./#simulation\_alphaTarget) - _alpha_) × [_alphaDecay_](./#simulation\_alphaDecay); then invokes each registered [force](./#simulation\_force), passing the new _alpha_; then decrements each [node](./#simulation\_nodes)’s velocity by _velocity_ × [_velocityDecay_](./#simulation\_velocityDecay); lastly increments each node’s position by _velocity_.

This method does not dispatch [events](./#simulation\_on); events are only dispatched by the internal timer when the simulation is started automatically upon [creation](./#forceSimulation) or by calling [_simulation_.restart](./#simulation\_restart). The natural number of ticks when the simulation is started is ⌈_log_([_alphaMin_](./#simulation\_alphaMin)) / _log_(1 - [_alphaDecay_](./#simulation\_alphaDecay))⌉; by default, this is 300.

This method can be used in conjunction with [_simulation_.stop](./#simulation\_stop) to compute a [static force layout](https://bl.ocks.org/mbostock/1667139). For large graphs, static layouts should be computed [in a web worker](https://bl.ocks.org/mbostock/01ab2e85e8727d6529d20391c0fd9a16) to avoid freezing the user interface.

[#](./#simulation\_nodes) _simulation_.nodes(\[_nodes_]) · [Source](https://github.com/d3/d3-force/blob/master/src/simulation.js)

If _nodes_ is specified, sets the simulation’s nodes to the specified array of objects, initializing their positions and velocities if necessary, and then [re-initializes](./#force\_initialize) any bound [forces](./#simulation\_force); returns the simulation. If _nodes_ is not specified, returns the simulation’s array of nodes as specified to the [constructor](./#forceSimulation).

Each _node_ must be an object. The following properties are assigned by the simulation:

* `index` - the node’s zero-based index into _nodes_
* `x` - the node’s current _x_-position
* `y` - the node’s current _y_-position
* `vx` - the node’s current _x_-velocity
* `vy` - the node’s current _y_-velocity

The position ⟨_x_,_y_⟩ and velocity ⟨_vx_,_vy_⟩ may be subsequently modified by [forces](./#forces) and by the simulation. If either _vx_ or _vy_ is NaN, the velocity is initialized to ⟨0,0⟩. If either _x_ or _y_ is NaN, the position is initialized in a [phyllotaxis arrangement](https://observablehq.com/@d3/force-layout-phyllotaxis), so chosen to ensure a deterministic, uniform distribution.

To fix a node in a given position, you may specify two additional properties:

* `fx` - the node’s fixed _x_-position
* `fy` - the node’s fixed _y_-position

At the end of each [tick](./#simulation\_tick), after the application of any forces, a node with a defined _node_.fx has _node_.x reset to this value and _node_.vx set to zero; likewise, a node with a defined _node_.fy has _node_.y reset to this value and _node_.vy set to zero. To unfix a node that was previously fixed, set _node_.fx and _node_.fy to null, or delete these properties.

If the specified array of _nodes_ is modified, such as when nodes are added to or removed from the simulation, this method must be called again with the new (or changed) array to notify the simulation and bound forces of the change; the simulation does not make a defensive copy of the specified array.

[#](./#simulation\_alpha) _simulation_.alpha(\[_alpha_]) · [Source](https://github.com/d3/d3-force/blob/master/src/simulation.js)

_alpha_ is roughly analogous to temperature in [simulated annealing](https://en.wikipedia.org/wiki/Simulated\_annealing#Overview). It decreases over time as the simulation “cools down”. When _alpha_ reaches _alphaMin_, the simulation stops; see [_simulation_.restart](./#simulation\_restart).

If _alpha_ is specified, sets the current alpha to the specified number in the range \[0,1] and returns this simulation. If _alpha_ is not specified, returns the current alpha value, which defaults to 1.

[#](./#simulation\_alphaMin) _simulation_.alphaMin(\[_min_]) · [Source](https://github.com/d3/d3-force/blob/master/src/simulation.js)

If _min_ is specified, sets the minimum _alpha_ to the specified number in the range \[0,1] and returns this simulation. If _min_ is not specified, returns the current minimum _alpha_ value, which defaults to 0.001. The simulation’s internal timer stops when the current [_alpha_](./#simulation\_alpha) is less than the minimum _alpha_. The default [alpha decay rate](./#simulation\_alphaDecay) of \~0.0228 corresponds to 300 iterations.

[#](./#simulation\_alphaDecay) _simulation_.alphaDecay(\[_decay_]) · [Source](https://github.com/d3/d3-force/blob/master/src/simulation.js)

If _decay_ is specified, sets the [_alpha_](./#simulation\_alpha) decay rate to the specified number in the range \[0,1] and returns this simulation. If _decay_ is not specified, returns the current _alpha_ decay rate, which defaults to 0.0228… = 1 - _pow_(0.001, 1 / 300) where 0.001 is the default [minimum _alpha_](./#simulation\_alphaMin).

The alpha decay rate determines how quickly the current alpha interpolates towards the desired [target _alpha_](./#simulation\_alphaTarget); since the default target _alpha_ is zero, by default this controls how quickly the simulation cools. Higher decay rates cause the simulation to stabilize more quickly, but risk getting stuck in a local minimum; lower values cause the simulation to take longer to run, but typically converge on a better layout. To have the simulation run forever at the current _alpha_, set the _decay_ rate to zero; alternatively, set a [target _alpha_](./#simulation\_alphaTarget) greater than the [minimum _alpha_](./#simulation\_alphaMin).

[#](./#simulation\_alphaTarget) _simulation_.alphaTarget(\[_target_]) · [Source](https://github.com/d3/d3-force/blob/master/src/simulation.js)

If _target_ is specified, sets the current target [_alpha_](./#simulation\_alpha) to the specified number in the range \[0,1] and returns this simulation. If _target_ is not specified, returns the current target alpha value, which defaults to 0.

[#](./#simulation\_velocityDecay) _simulation_.velocityDecay(\[_decay_]) · [Source](https://github.com/d3/d3-force/blob/master/src/simulation.js)

If _decay_ is specified, sets the velocity decay factor to the specified number in the range \[0,1] and returns this simulation. If _decay_ is not specified, returns the current velocity decay factor, which defaults to 0.4. The decay factor is akin to atmospheric friction; after the application of any forces during a [tick](./#simulation\_tick), each node’s velocity is multiplied by 1 - _decay_. As with lowering the [alpha decay rate](./#simulation\_alphaDecay), less velocity decay may converge on a better solution, but risks numerical instabilities and oscillation.

[#](./#simulation\_force) _simulation_.force(_name_\[, _force_]) · [Source](https://github.com/d3/d3-force/blob/master/src/simulation.js)

If _force_ is specified, assigns the [force](./#forces) for the specified _name_ and returns this simulation. If _force_ is not specified, returns the force with the specified name, or undefined if there is no such force. (By default, new simulations have no forces.) For example, to create a new simulation to layout a graph, you might say:

```js
var simulation = d3.forceSimulation(nodes)
    .force("charge", d3.forceManyBody())
    .force("link", d3.forceLink(links))
    .force("center", d3.forceCenter());
```

To remove the force with the given _name_, pass null as the _force_. For example, to remove the charge force:

```js
simulation.force("charge", null);
```

[#](./#simulation\_find) _simulation_.find(_x_, _y_\[, _radius_]) · [Source](https://github.com/d3/d3-force/blob/master/src/simulation.js)

Returns the node closest to the position ⟨_x_,_y_⟩ with the given search _radius_. If _radius_ is not specified, it defaults to infinity. If there is no node within the search area, returns undefined.

[#](./#simulation\_randomSource) _simulation_.randomSource(\[_source_]) [<>](https://github.com/d3/d3-force/blob/master/src/simulation.js))

If _source_ is specified, sets the function used to generate random numbers; this should be a function that returns a number between 0 (inclusive) and 1 (exclusive). If _source_ is not specified, returns this simulation’s current random source which defaults to a fixed-seed [linear congruential generator](https://en.wikipedia.org/wiki/Linear\_congruential\_generator). See also [_random_.source](https://github.com/d3/d3-random/blob/master/README.md#random\_source).

[#](./#simulation\_on) _simulation_.on(_typenames_, \[_listener_]) · [Source](https://github.com/d3/d3-force/blob/master/src/simulation.js)

If _listener_ is specified, sets the event _listener_ for the specified _typenames_ and returns this simulation. If an event listener was already registered for the same type and name, the existing listener is removed before the new listener is added. If _listener_ is null, removes the current event listeners for the specified _typenames_, if any. If _listener_ is not specified, returns the first currently-assigned listener matching the specified _typenames_, if any. When a specified event is dispatched, each _listener_ will be invoked with the `this` context as the simulation.

The _typenames_ is a string containing one or more _typename_ separated by whitespace. Each _typename_ is a _type_, optionally followed by a period (`.`) and a _name_, such as `tick.foo` and `tick.bar`; the name allows multiple listeners to be registered for the same _type_. The _type_ must be one of the following:

* `tick` - after each tick of the simulation’s internal timer.
* `end` - after the simulation’s timer stops when _alpha_ < [_alphaMin_](./#simulation\_alphaMin).

Note that _tick_ events are not dispatched when [_simulation_.tick](./#simulation\_tick) is called manually; events are only dispatched by the internal timer and are intended for interactive rendering of the simulation. To affect the simulation, register [forces](./#simulation\_force) instead of modifying nodes’ positions or velocities inside a tick event listener.

See [_dispatch_.on](https://github.com/d3/d3-dispatch#dispatch\_on) for details.

### Forces

A _force_ is simply a function that modifies nodes’ positions or velocities; in this context, a _force_ can apply a classical physical force such as electrical charge or gravity, or it can resolve a geometric constraint, such as keeping nodes within a bounding box or keeping linked nodes a fixed distance apart. For example, a simple positioning force that moves nodes towards the origin ⟨0,0⟩ might be implemented as:

```js
function force(alpha) {
  for (var i = 0, n = nodes.length, node, k = alpha * 0.1; i < n; ++i) {
    node = nodes[i];
    node.vx -= node.x * k;
    node.vy -= node.y * k;
  }
}
```

Forces typically read the node’s current position ⟨_x_,_y_⟩ and then add to (or subtract from) the node’s velocity ⟨_vx_,_vy_⟩. However, forces may also “peek ahead” to the anticipated next position of the node, ⟨_x_ + _vx_,_y_ + _vy_⟩; this is necessary for resolving geometric constraints through [iterative relaxation](https://en.wikipedia.org/wiki/Relaxation\_\(iterative\_method\)). Forces may also modify the position directly, which is sometimes useful to avoid adding energy to the simulation, such as when recentering the simulation in the viewport.

Simulations typically compose multiple forces as desired. This module provides several for your enjoyment:

* [Centering](./#centering)
* [Collision](./#collision)
* [Links](./#links)
* [Many-Body](./#many-body)
* [Positioning](./#positioning)

Forces may optionally implement [_force_.initialize](./#force\_initialize) to receive the simulation’s array of nodes.

[#](./#\_force) _force_(_alpha_) · [Source](https://github.com/d3/d3-force/blob/master/src/simulation.js)

Applies this force, optionally observing the specified _alpha_. Typically, the force is applied to the array of nodes previously passed to [_force_.initialize](./#force\_initialize), however, some forces may apply to a subset of nodes, or behave differently. For example, [d3.forceLink](./#links) applies to the source and target of each link.

[#](./#force\_initialize) _force_.initialize(_nodes_) · [Source](https://github.com/d3/d3-force/blob/master/src/simulation.js)

Supplies the array of _nodes_ and _random_ source to this force. This method is called when a force is bound to a simulation via [_simulation_.force](./#simulation\_force) and when the simulation’s nodes change via [_simulation_.nodes](./#simulation\_nodes). A force may perform necessary work during initialization, such as evaluating per-node parameters, to avoid repeatedly performing work during each application of the force.

#### Centering

The centering force translates nodes uniformly so that the mean position of all nodes (the center of mass if all nodes have equal weight) is at the given position ⟨[_x_](./#center\_x),[_y_](./#center\_y)⟩. This force modifies the positions of nodes on each application; it does not modify velocities, as doing so would typically cause the nodes to overshoot and oscillate around the desired center. This force helps keeps nodes in the center of the viewport, and unlike the [positioning force](./#positioning), it does not distort their relative positions.

[#](./#forceCenter) d3.forceCenter(\[_x_, _y_]) · [Source](https://github.com/d3/d3-force/blob/master/src/center.js)

Creates a new centering force with the specified [_x_-](./#center\_x) and [_y_-](./#center\_y) coordinates. If _x_ and _y_ are not specified, they default to ⟨0,0⟩.

[#](./#center\_x) _center_.x(\[_x_]) · [Source](https://github.com/d3/d3-force/blob/master/src/center.js)

If _x_ is specified, sets the _x_-coordinate of the centering position to the specified number and returns this force. If _x_ is not specified, returns the current _x_-coordinate, which defaults to zero.

[#](./#center\_y) _center_.y(\[_y_]) · [Source](https://github.com/d3/d3-force/blob/master/src/center.js)

If _y_ is specified, sets the _y_-coordinate of the centering position to the specified number and returns this force. If _y_ is not specified, returns the current _y_-coordinate, which defaults to zero.

[#](./#center\_strength) _center_.strength(\[_strength_]) · [Source](https://github.com/d3/d3-force/blob/master/src/center.js), [Examples](https://observablehq.com/@d3/forcecenter-strength)

If _strength_ is specified, sets the centering force’s strength. A reduced strength of e.g. 0.05 softens the movements on interactive graphs in which new nodes enter or exit the graph. If _strength_ is not specified, returns the force’s current strength, which defaults to 1.

#### Collision

The collision force treats nodes as circles with a given [radius](./#collide\_radius), rather than points, and prevents nodes from overlapping. More formally, two nodes _a_ and _b_ are separated so that the distance between _a_ and _b_ is at least _radius_(_a_) + _radius_(_b_). To reduce jitter, this is by default a “soft” constraint with a configurable [strength](./#collide\_strength) and [iteration count](./#collide\_iterations).

[#](./#forceCollide) d3.forceCollide(\[_radius_]) · [Source](https://github.com/d3/d3-force/blob/master/src/collide.js)

Creates a new circle collision force with the specified [_radius_](./#collide\_radius). If _radius_ is not specified, it defaults to the constant one for all nodes.

[#](./#collide\_radius) _collide_.radius(\[_radius_]) · [Source](https://github.com/d3/d3-force/blob/master/src/collide.js)

If _radius_ is specified, sets the radius accessor to the specified number or function, re-evaluates the radius accessor for each node, and returns this force. If _radius_ is not specified, returns the current radius accessor, which defaults to:

```js
function radius() {
  return 1;
}
```

The radius accessor is invoked for each [node](./#simulation\_nodes) in the simulation, being passed the _node_ and its zero-based _index_. The resulting number is then stored internally, such that the radius of each node is only recomputed when the force is initialized or when this method is called with a new _radius_, and not on every application of the force.

[#](./#collide\_strength) _collide_.strength(\[_strength_]) · [Source](https://github.com/d3/d3-force/blob/master/src/collide.js)

If _strength_ is specified, sets the force strength to the specified number in the range \[0,1] and returns this force. If _strength_ is not specified, returns the current strength which defaults to 1.

Overlapping nodes are resolved through iterative relaxation. For each node, the other nodes that are anticipated to overlap at the next tick (using the anticipated positions ⟨_x_ + _vx_,_y_ + _vy_⟩) are determined; the node’s velocity is then modified to push the node out of each overlapping node. The change in velocity is dampened by the force’s strength such that the resolution of simultaneous overlaps can be blended together to find a stable solution.

[#](./#collide\_iterations) _collide_.iterations(\[_iterations_]) · [Source](https://github.com/d3/d3-force/blob/master/src/collide.js)

If _iterations_ is specified, sets the number of iterations per application to the specified number and returns this force. If _iterations_ is not specified, returns the current iteration count which defaults to 1. Increasing the number of iterations greatly increases the rigidity of the constraint and avoids partial overlap of nodes, but also increases the runtime cost to evaluate the force.

#### Links

The link force pushes linked nodes together or apart according to the desired [link distance](./#link\_distance). The strength of the force is proportional to the difference between the linked nodes’ distance and the target distance, similar to a spring force.

[#](./#forceLink) d3.forceLink(\[_links_]) · [Source](https://github.com/d3/d3-force/blob/master/src/link.js)

Creates a new link force with the specified _links_ and default parameters. If _links_ is not specified, it defaults to the empty array.

[#](./#link\_links) _link_.links(\[_links_]) · [Source](https://github.com/d3/d3-force/blob/master/src/link.js)

If _links_ is specified, sets the array of links associated with this force, recomputes the [distance](./#link\_distance) and [strength](./#link\_strength) parameters for each link, and returns this force. If _links_ is not specified, returns the current array of links, which defaults to the empty array.

Each link is an object with the following properties:

* `source` - the link’s source node; see [_simulation_.nodes](./#simulation\_nodes)
* `target` - the link’s target node; see [_simulation_.nodes](./#simulation\_nodes)
* `index` - the zero-based index into _links_, assigned by this method

For convenience, a link’s source and target properties may be initialized using numeric or string identifiers rather than object references; see [_link_.id](./#link\_id). When the link force is [initialized](./#force\_initialize) (or re-initialized, as when the nodes or links change), any _link_.source or _link_.target property which is _not_ an object is replaced by an object reference to the corresponding _node_ with the given identifier.

If the specified array of _links_ is modified, such as when links are added to or removed from the simulation, this method must be called again with the new (or changed) array to notify the force of the change; the force does not make a defensive copy of the specified array.

[#](./#link\_id) _link_.id(\[_id_]) · [Source](https://github.com/d3/d3-force/blob/master/src/link.js)

If _id_ is specified, sets the node id accessor to the specified function and returns this force. If _id_ is not specified, returns the current node id accessor, which defaults to the numeric _node_.index:

```js
function id(d) {
  return d.index;
}
```

The default id accessor allows each link’s source and target to be specified as a zero-based index into the [nodes](./#simulation\_nodes) array. For example:

```js
var nodes = [
  {"id": "Alice"},
  {"id": "Bob"},
  {"id": "Carol"}
];

var links = [
  {"source": 0, "target": 1}, // Alice → Bob
  {"source": 1, "target": 2} // Bob → Carol
];
```

Now consider a different id accessor that returns a string:

```js
function id(d) {
  return d.id;
}
```

With this accessor, you can use named sources and targets:

```js
var nodes = [
  {"id": "Alice"},
  {"id": "Bob"},
  {"id": "Carol"}
];

var links = [
  {"source": "Alice", "target": "Bob"},
  {"source": "Bob", "target": "Carol"}
];
```

This is particularly useful when representing graphs in JSON, as JSON does not allow references. See [this example](https://bl.ocks.org/mbostock/f584aa36df54c451c94a9d0798caed35).

The id accessor is invoked for each node whenever the force is initialized, as when the [nodes](./#simulation\_nodes) or [links](./#link\_links) change, being passed the node and its zero-based index.

[#](./#link\_distance) _link_.distance(\[_distance_]) · [Source](https://github.com/d3/d3-force/blob/master/src/link.js)

If _distance_ is specified, sets the distance accessor to the specified number or function, re-evaluates the distance accessor for each link, and returns this force. If _distance_ is not specified, returns the current distance accessor, which defaults to:

```js
function distance() {
  return 30;
}
```

The distance accessor is invoked for each [link](./#link\_links), being passed the _link_ and its zero-based _index_. The resulting number is then stored internally, such that the distance of each link is only recomputed when the force is initialized or when this method is called with a new _distance_, and not on every application of the force.

[#](./#link\_strength) _link_.strength(\[_strength_]) · [Source](https://github.com/d3/d3-force/blob/master/src/link.js)

If _strength_ is specified, sets the strength accessor to the specified number or function, re-evaluates the strength accessor for each link, and returns this force. If _strength_ is not specified, returns the current strength accessor, which defaults to:

```js
function strength(link) {
  return 1 / Math.min(count(link.source), count(link.target));
}
```

Where _count_(_node_) is a function that returns the number of links with the given node as a source or target. This default was chosen because it automatically reduces the strength of links connected to heavily-connected nodes, improving stability.

The strength accessor is invoked for each [link](./#link\_links), being passed the _link_ and its zero-based _index_. The resulting number is then stored internally, such that the strength of each link is only recomputed when the force is initialized or when this method is called with a new _strength_, and not on every application of the force.

[#](./#link\_iterations) _link_.iterations(\[_iterations_]) · [Source](https://github.com/d3/d3-force/blob/master/src/link.js)

If _iterations_ is specified, sets the number of iterations per application to the specified number and returns this force. If _iterations_ is not specified, returns the current iteration count which defaults to 1. Increasing the number of iterations greatly increases the rigidity of the constraint and is useful for [complex structures such as lattices](https://observablehq.com/@d3/force-directed-lattice), but also increases the runtime cost to evaluate the force.

#### Many-Body

The many-body (or _n_-body) force applies mutually amongst all [nodes](./#simulation\_nodes). It can be used to simulate gravity (attraction) if the [strength](./#manyBody\_strength) is positive, or electrostatic charge (repulsion) if the strength is negative. This implementation uses quadtrees and the [Barnes–Hut approximation](https://en.wikipedia.org/wiki/Barnes%E2%80%93Hut\_simulation) to greatly improve performance; the accuracy can be customized using the [theta](./#manyBody\_theta) parameter.

Unlike links, which only affect two linked nodes, the charge force is global: every node affects every other node, even if they are on disconnected subgraphs.

[#](./#forceManyBody) d3.forceManyBody() · [Source](https://github.com/d3/d3-force/blob/master/src/manyBody.js)

Creates a new many-body force with the default parameters.

[#](./#manyBody\_strength) _manyBody_.strength(\[_strength_]) · [Source](https://github.com/d3/d3-force/blob/master/src/manyBody.js)

If _strength_ is specified, sets the strength accessor to the specified number or function, re-evaluates the strength accessor for each node, and returns this force. A positive value causes nodes to attract each other, similar to gravity, while a negative value causes nodes to repel each other, similar to electrostatic charge. If _strength_ is not specified, returns the current strength accessor, which defaults to:

```js
function strength() {
  return -30;
}
```

The strength accessor is invoked for each [node](./#simulation\_nodes) in the simulation, being passed the _node_ and its zero-based _index_. The resulting number is then stored internally, such that the strength of each node is only recomputed when the force is initialized or when this method is called with a new _strength_, and not on every application of the force.

[#](./#manyBody\_theta) _manyBody_.theta(\[_theta_]) · [Source](https://github.com/d3/d3-force/blob/master/src/manyBody.js)

If _theta_ is specified, sets the Barnes–Hut approximation criterion to the specified number and returns this force. If _theta_ is not specified, returns the current value, which defaults to 0.9.

To accelerate computation, this force implements the [Barnes–Hut approximation](http://en.wikipedia.org/wiki/Barnes%E2%80%93Hut\_simulation) which takes O(_n_ log _n_) per application where _n_ is the number of [nodes](./#simulation\_nodes). For each application, a [quadtree](https://github.com/d3/d3-quadtree) stores the current node positions; then for each node, the combined force of all other nodes on the given node is computed. For a cluster of nodes that is far away, the charge force can be approximated by treating the cluster as a single, larger node. The _theta_ parameter determines the accuracy of the approximation: if the ratio _w_ / _l_ of the width _w_ of the quadtree cell to the distance _l_ from the node to the cell’s center of mass is less than _theta_, all nodes in the given cell are treated as a single node rather than individually.

[#](./#manyBody\_distanceMin) _manyBody_.distanceMin(\[_distance_]) · [Source](https://github.com/d3/d3-force/blob/master/src/manyBody.js)

If _distance_ is specified, sets the minimum distance between nodes over which this force is considered. If _distance_ is not specified, returns the current minimum distance, which defaults to 1. A minimum distance establishes an upper bound on the strength of the force between two nearby nodes, avoiding instability. In particular, it avoids an infinitely-strong force if two nodes are exactly coincident; in this case, the direction of the force is random.

[#](./#manyBody\_distanceMax) _manyBody_.distanceMax(\[_distance_]) · [Source](https://github.com/d3/d3-force/blob/master/src/manyBody.js)

If _distance_ is specified, sets the maximum distance between nodes over which this force is considered. If _distance_ is not specified, returns the current maximum distance, which defaults to infinity. Specifying a finite maximum distance improves performance and produces a more localized layout.

#### Positioning

The [_x_](./#forceX)- and [_y_](./#forceY)-positioning forces push nodes towards a desired position along the given dimension with a configurable strength. The [_radial_](./#forceRadial) force is similar, except it pushes nodes towards the closest point on a given circle. The strength of the force is proportional to the one-dimensional distance between the node’s position and the target position. While these forces can be used to position individual nodes, they are intended primarily for global forces that apply to all (or most) nodes.

[#](./#forceX) d3.forceX(\[_x_]) · [Source](https://github.com/d3/d3-force/blob/master/src/x.js)

Creates a new positioning force along the _x_-axis towards the given position [_x_](./#x\_x). If _x_ is not specified, it defaults to 0.

[#](./#x\_strength) _x_.strength(\[_strength_]) · [Source](https://github.com/d3/d3-force/blob/master/src/x.js)

If _strength_ is specified, sets the strength accessor to the specified number or function, re-evaluates the strength accessor for each node, and returns this force. The _strength_ determines how much to increment the node’s _x_-velocity: ([_x_](./#x\_x) - _node_.x) × _strength_. For example, a value of 0.1 indicates that the node should move a tenth of the way from its current _x_-position to the target _x_-position with each application. Higher values moves nodes more quickly to the target position, often at the expense of other forces or constraints. A value outside the range \[0,1] is not recommended.

If _strength_ is not specified, returns the current strength accessor, which defaults to:

```js
function strength() {
  return 0.1;
}
```

The strength accessor is invoked for each [node](./#simulation\_nodes) in the simulation, being passed the _node_ and its zero-based _index_. The resulting number is then stored internally, such that the strength of each node is only recomputed when the force is initialized or when this method is called with a new _strength_, and not on every application of the force.

[#](./#x\_x) _x_.x(\[_x_]) · [Source](https://github.com/d3/d3-force/blob/master/src/x.js)

If _x_ is specified, sets the _x_-coordinate accessor to the specified number or function, re-evaluates the _x_-accessor for each node, and returns this force. If _x_ is not specified, returns the current _x_-accessor, which defaults to:

```js
function x() {
  return 0;
}
```

The _x_-accessor is invoked for each [node](./#simulation\_nodes) in the simulation, being passed the _node_ and its zero-based _index_. The resulting number is then stored internally, such that the target _x_-coordinate of each node is only recomputed when the force is initialized or when this method is called with a new _x_, and not on every application of the force.

[#](./#forceY) d3.forceY(\[_y_]) · [Source](https://github.com/d3/d3-force/blob/master/src/y.js)

Creates a new positioning force along the _y_-axis towards the given position [_y_](./#y\_y). If _y_ is not specified, it defaults to 0.

[#](./#y\_strength) _y_.strength(\[_strength_]) · [Source](https://github.com/d3/d3-force/blob/master/src/y.js)

If _strength_ is specified, sets the strength accessor to the specified number or function, re-evaluates the strength accessor for each node, and returns this force. The _strength_ determines how much to increment the node’s _y_-velocity: ([_y_](./#y\_y) - _node_.y) × _strength_. For example, a value of 0.1 indicates that the node should move a tenth of the way from its current _y_-position to the target _y_-position with each application. Higher values moves nodes more quickly to the target position, often at the expense of other forces or constraints. A value outside the range \[0,1] is not recommended.

If _strength_ is not specified, returns the current strength accessor, which defaults to:

```js
function strength() {
  return 0.1;
}
```

The strength accessor is invoked for each [node](./#simulation\_nodes) in the simulation, being passed the _node_ and its zero-based _index_. The resulting number is then stored internally, such that the strength of each node is only recomputed when the force is initialized or when this method is called with a new _strength_, and not on every application of the force.

[#](./#y\_y) _y_.y(\[_y_]) · [Source](https://github.com/d3/d3-force/blob/master/src/y.js)

If _y_ is specified, sets the _y_-coordinate accessor to the specified number or function, re-evaluates the _y_-accessor for each node, and returns this force. If _y_ is not specified, returns the current _y_-accessor, which defaults to:

```js
function y() {
  return 0;
}
```

The _y_-accessor is invoked for each [node](./#simulation\_nodes) in the simulation, being passed the _node_ and its zero-based _index_. The resulting number is then stored internally, such that the target _y_-coordinate of each node is only recomputed when the force is initialized or when this method is called with a new _y_, and not on every application of the force.

[#](./#forceRadial) d3.forceRadial(_radius_\[, _x_]\[, _y_]) · [Source](https://github.com/d3/d3-force/blob/master/src/radial.js)

[![Radial Force](https://raw.githubusercontent.com/d3/d3-force/master/img/radial.png)](https://bl.ocks.org/mbostock/cd98bf52e9067e26945edd95e8cf6ef9)

Creates a new positioning force towards a circle of the specified [_radius_](./#radial\_radius) centered at ⟨[_x_](./#radial\_x),[_y_](./#radial\_y)⟩. If _x_ and _y_ are not specified, they default to ⟨0,0⟩.

[#](./#radial\_strength) _radial_.strength(\[_strength_]) · [Source](https://github.com/d3/d3-force/blob/master/src/radial.js)

If _strength_ is specified, sets the strength accessor to the specified number or function, re-evaluates the strength accessor for each node, and returns this force. The _strength_ determines how much to increment the node’s _x_- and _y_-velocity. For example, a value of 0.1 indicates that the node should move a tenth of the way from its current position to the closest point on the circle with each application. Higher values moves nodes more quickly to the target position, often at the expense of other forces or constraints. A value outside the range \[0,1] is not recommended.

If _strength_ is not specified, returns the current strength accessor, which defaults to:

```js
function strength() {
  return 0.1;
}
```

The strength accessor is invoked for each [node](./#simulation\_nodes) in the simulation, being passed the _node_ and its zero-based _index_. The resulting number is then stored internally, such that the strength of each node is only recomputed when the force is initialized or when this method is called with a new _strength_, and not on every application of the force.

[#](./#radial\_radius) _radial_.radius(\[_radius_]) · [Source](https://github.com/d3/d3-force/blob/master/src/radial.js)

If _radius_ is specified, sets the circle _radius_ to the specified number or function, re-evaluates the _radius_ accessor for each node, and returns this force. If _radius_ is not specified, returns the current _radius_ accessor.

The _radius_ accessor is invoked for each [node](./#simulation\_nodes) in the simulation, being passed the _node_ and its zero-based _index_. The resulting number is then stored internally, such that the target radius of each node is only recomputed when the force is initialized or when this method is called with a new _radius_, and not on every application of the force.

[#](./#radial\_x) _radial_.x(\[_x_]) · [Source](https://github.com/d3/d3-force/blob/master/src/radial.js)

If _x_ is specified, sets the _x_-coordinate of the circle center to the specified number and returns this force. If _x_ is not specified, returns the current _x_-coordinate of the center, which defaults to zero.

[#](./#radial\_y) _radial_.y(\[_y_]) · [Source](https://github.com/d3/d3-force/blob/master/src/radial.js)

If _y_ is specified, sets the _y_-coordinate of the circle center to the specified number and returns this force. If _y_ is not specified, returns the current _y_-coordinate of the center, which defaults to zero.
